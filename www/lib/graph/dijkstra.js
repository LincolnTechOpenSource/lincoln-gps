/*
 * dijkstra.js
 * Matthew Vasseur
 * 06/01/16
 *
 * runs Dijkstra's shortest path algorithm on a graph
 /*---------------------------------------------------------------------------*/

var Dijkstra = {}; // create namespace

/*
 * Dijkstra.run: run Dijkstra's shortest path algorithm
 * returns an array of the shortest path from source to target, [] if one DNE
 * @source: the starting point for the path (a node ID)
 * @target: the ending point for the path (a node ID)
 * @graph: the graph on which to run algorithm`
 */
 Dijkstra.run = function (source, target, graph) {
    // binary min heap of the unvisited nodes (on distance)
    var unvisited = new BinaryHeap(
        function (e) { return e.distance; },
        function (e) { return e._id },
        'distance'
    );
    var dist = {}; // distance of the node from source
    var prev = {}; // previous node of the form 'node_id': 'prev_node_id'

    _assert(graph._nodes[source] !== undefined, "Source does not exist (" +
        source + ")");
    _assert(graph._nodes[target] !== undefined, "Target does not exist (" +
        target + ")");

    // Initialization
    dist[source] = 0; // source is distance 0 from source
    for (var i of Object.keys(graph._nodes)) {
        // for each node in the graph...
        var node = graph._nodes[i];

        if (node._id != source) {
            prev[node._id] = null; // set previous to undefined
            dist[node._id] = Infinity; // set distance to Infinity
        }
        // push node to unvisited with distance Infinity
        unvisited.push( {_id: node._id, distance: dist[node._id]} );
    }

    // return if source is the same as target (i.e., already there)
    if (source === target) return {dist, prev};

    // The loop of the algorithm
    // while there are still unvisited nodes
    while (unvisited.size() > 0) {
        var minNode = unvisited.pop(); // get minimum node dist and ID

        // for each neighbor of minNode that is in the unvisited queue
        for (var i = 0; i < graph._nodes[minNode._id]._neighbors.length; i++) {
            var n = graph._nodes[graph._nodes[minNode._id]._neighbors[i]];

            // ensure node is in unvisited and it is a PATH
            if (!unvisited.exists(n) && n._ntype == NodeTypeEnum.PATH)
                continue;

            // calculate alternative distance
            var alt = minNode.distance + graph.edgeWeight(minNode._id, n._id);

            // use this path instead, if alternative distance is shorter
            if (alt < dist[n._id]) {
                dist[n._id] = alt;
                prev[n._id] = minNode._id;
                unvisited.decreaseKey(n._id, alt); // update key
            }
        }
    }

    return {dist, prev}; // return distances and previous
};

/*
 * Dijkstra.getPath: gets the path given the previous array from Dijkstra's algorithm
 * @prev: the previous array generated by a run of Dijkstra's
 * @target: the end of the path
 */
Dijkstra.getPath = function (prev, target) {
    var path = []; // the path to return
    var t = target;

    while (prev[t] !== undefined && prev[t] !== null) {
        path.unshift(t);
        t = prev[t];
    }

    return path;
};

/*
 * assert: debugging function
 * @condition: condition that should be true
 * @message: error message to display in failure
 */
function _assert(condition, message) {
    if (!condition) {
        message = message || "Assertion failed";
        if (typeof Error !== "undefined") {
            throw new Error(message);
        }
        throw message; // Fallback
    }
}

/*----------------------------------------------------------------------------*/
